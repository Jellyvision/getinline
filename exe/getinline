#!/usr/bin/env ruby

$LOAD_PATH.unshift File.expand_path('../../lib', __FILE__)

require 'getinline'
require 'optparse'

options = {}

option_parser = OptionParser.new do |opts|
  executable_name = File.basename($PROGRAM_NAME)
  opts.banner = "A CSS inliner for Ruby ERB templates.\n\n"
  opts.define_head "Usage: getinline <optional path> [options]"
  opts.separator ""
  opts.separator "Examples:"
  opts.separator "  #{executable_name} ./public/index.html"
  opts.separator "  #{executable_name} < ./public/index.html"
  opts.separator "  cat ./public/index.html | #{executable_name}"
  opts.separator ""
  opts.separator "Options: "

  opts.on('-h', '--help', 'Print usage instructions') do
    puts option_parser
    exit
  end
end

begin
  option_parser.parse!
rescue OptionParser::InvalidOption => error
  abort "Getinline doesn't recognize that #{error}"
rescue OptionParser::AmbiguousOption => error
  abort "That's an #{error}"
end

def transform (file_contents)
  transformer = Getinline::Transformer.new(file_contents)
  puts transformer.transform
end

if ARGF.filename != '-' or (not STDIN.tty? and not STDIN.closed?)
  transform ARGF.read
else
  puts option_parser
  exit
end